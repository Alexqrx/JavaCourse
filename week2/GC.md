UseSerialGC:串行化gc,对年轻代进行mark-copy(标记-复制)，对老年代进行mark-sweep-compact(标记-清除-整理)，是一个单线程的垃圾回收器，触发串行GC的时候，会停掉所有的应用线程。启动时设置的堆内存越大，第一次young区分配的空间就大，单位时间内GC次数会越来越少，并且会越来越晚的出现FULLGC。
UseParallelGC：并行gc年轻代和老年代的垃圾回收都会触发STW事件。年轻代使用标记复制算法，老年代使用标记清除整理算法，可以指定GC线程数，默认是CPU核数。并行垃圾回收器适用于多核服务器，在GC期间所有的CPU都在进行垃圾回收，所以耗时很短，两次GC期间没有GC线程运行，不占用系统资源。将堆内存设置的越大之后，出现FULLGC 的时间越晚，但是每次GC的时间会边长，说明使用并行GC进行垃圾回收的话，并不是将堆内存设置越大越好，会影响吞吐量。
UseConcMarkSweepGC：其对年轻代采用并行STW 方式的mark-copy(标记-复制)算法，对老年代主要使用并发mark-sweep (标记-清除)算法。CMSGC的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。在mark-and-sweep（标记-清除）阶段的大部分工作和应用线程一起并发执行。也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢CPU时。默认情况下，CMS使用的并发线程数等于CPU核心数的1/4。如果服务器是多核CPU，并且主要调优目标是降低GC停顿导致的系统延迟，那么使用CMS是个很明智的选择。进行老年代的并发回收时，可能会伴随着多次年轻代的minor GC。
G1GC:G1 的全称是Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它。G1 GC最主要的设计目标是：将STW停顿的时间和分布，变成可预期且可配置的。事实上，G1GC是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。为了达成可预期停顿时间的指标，G1GC有一些独特的实现。首先，堆不再分成年轻代和老年代，而是划分为多个（通常是2048个）可以存放对象的小块堆区域(smallerheapregions)。每个小块，可能一会被定义成Eden 区，一会被指定为Survivor区或者Old 区。在逻辑上，所有的Eden 区和Survivor区合起来就是年轻代，所有的Old 区拼在一起那就是老年代。G1gc增大堆内存的话划分的每个堆就会变大，相应的标记清除时间会变长。

疑问：在做压力测试中会出现Status:303的情况，个人理解出现这个的原因和启动内存，网络速度，请求并发数，请求时长有一定的关系。